<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Защо трябва да обичаме Haskell? PlovdivConf 2014</title>

		<meta name="description" content="Презентация за PlovdivConf 2014. Аргументи защо е хубаво човек да попише Haskell.">
		<meta name="author" content="RadoRado">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', include the PDF print sheet -->
		<script>
			if( window.location.search.match( /print-pdf/gi ) ) {
				var link = document.createElement( 'link' );
				link.rel = 'stylesheet';
				link.type = 'text/css';
				link.href = 'css/print/pdf.css';
				document.getElementsByTagName( 'head' )[0].appendChild( link );
			}
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
                    <img src="images/haskell_front.png" />
				</section>

                <section>
                    <h1>Защо трябва да обичаме Haskell?</h1>
                    <h3>PlovdivConf 2014</h3>
                    <img src="images/plovdivconf.png" >
                </section>

                <section>
                    <h2>Аз съм РадоРадо</h2>
                    <p>Тъй като може да не ми стигне времето, ще се представя накрая.</p>
 <!--                                        <pre>
                                            <code data-trim contenteditable class="haskell">
                    name :: String
                    name = "RadoRado"
                                            </code>
                                        </pre> -->
                </section>

                <section>
                    <h2>Тази презентация има <strong>три</strong> основни цели</h2>
                    <p>
                        <ol>
                            <li class="fragment">Да се замислите върху това как пишете код.</li>
                            <li class="fragment"><em>След като се приберете у вас, да разцъкате Haskell.</em></li>
                            <li class="fragment"><strong>Да станете по-добри програмисти.</strong></li>
                            <li class="fragment">(Няма да ви карам да си сменяте езика на Haskell.)</li>
                        </ol>
                    </p>
                </section>

                <section>
                    <h2>Бърза Agenda</h2>
                    <h3 class="fragment">1. Малко мотивация за Haskell.</h3>
                    <h3 class="fragment">2. Haskell crash course.</h3>
                    <h3 class="fragment">3. Ще направим едно просто приложение с IO.</h3>
                </section>

                <section>
                    <h2>Все повече езици се движат към "функционалната" парадигма.</h2>
                </section>

                <section>
                    <img src="images/graph.jpg">
                </section>

                <section>
                    <h2>Haskell сe води <strong>неизползваем език</strong>.</h2>
                    <img src="images/haskell.png" />
                </section>

                <section>
                    <h2>В Haskell има толкова много неща за учене, че граничи с неизползваемост, но ...</h2>
                </section>

                <section>
                    <h2>Има и много добри идеи, с които човек си заслужава да се запознае.</h2>
                </section>

                <section>
                    <h2>Писането на Haskell те кара да мислиш.</h2>
                    <p>Както <strong>за решаването на проблема</strong>, така и <strong>за дизайна на кода</strong>.</p>
                </section>

                <section>
                    <img src="images/survival.jpg" />
                </section>

                <section>
                    <h2>Какво представлява Haskell?</h2>
                    <pre><code class="haskell">
module Split ( split ) where

split :: Eq a => [a] -> [a] -> [[a]]
split delimiter items = splitIter delimiter items [[]]
  where
    delimiterLength = length delimiter
    splitIter _ [] result = result
    splitIter xs (y:ys) result@(r:rs)
      | xs == (take delimiterLength (y:ys)) = splitIter xs (drop delimiterLength (y:ys)) ([] : result)
      | otherwise = splitIter xs ys ((y:r):rs)
</code></pre>
                </section>

                <section>
                    <h2>Език без променливи.</h2>
                    <p>a = a + 1 не съществува</p>
                </section>

                <section>
                    <h2>Език без структури за цикъл.</h2>
                    <p>Рекурсията е вашият най-добър приятел.</p>
                </section>

                <section>
                    <h2><strong>Pure</strong> Functional Language.</h2>
                    <p><strong>No Side Effects.</strong></p>
                </section>

                <section>
                    <h2><strong>Side effect</strong> = changing something somewhere.</h2>
                    <ul>
                        <li>Променяне на стойност на променлива.</li>
                        <li>Писане в база от данни.</li>
                        <li>Промяна на състоянието в някакъв UI.</li>
                    </ul>
                </section>

                <section>
                    <p>Викаме два пъти една и съща функция. Получаваме различен резултат.</p>
                    <pre><code class="python">
# Python

x = 2;

def inc_x():
    global x
    x = x + 1


def times_x(n):
    global x
    return x * n

times_x(5)
inc_x()
times_x(5)
</code></pre>
                </section>


                <section>
                    <h2>Pure Functions.</h2>
                    <ul>
                        <li>Без глобален state.</li>
                        <li>Без странични ефекти.</li>
                        <li>Винаги връщат стойност.</li>
                    </ul>
                    <pre><code class="haskell">
-- a.hs (this is a comment)
f x = x * x
                    </code></pre>
                </section>

                <section>
                    <h2>Силно типизиран език.</h2>
                    <pre><code class="haskell">
-- b.hs
inInterval :: Int -> Int -> Int -> Bool
inInterval a b x = x >= a && x <= b
                    </code></pre>
                </section>

                <section>
                    <h2>Type Inference.</h2>
                    <p>Компилаторът е по-умен от нас.</p>
                    <pre><code class="haskell">
-- c.hs
confIt cities = map (\city -> city ++ "Conf") cities</code></pre>

                    <pre><code>
*Main> confIt ["Plovdiv", "Varna", "Tarnovo", "Pleven"]
["PlovdivConf","VarnaConf","TarnovoConf","PlevenConf"]
*Main> :t confIt
confIt :: [[Char]] -> [[Char]]
</code></pre>
                </section>

                <section>
                    <h2>confIt :: [[Char]] -> [[Char]]</h2>
                    <p>String = [Char]</p>
                </section>

                <section>
                    <h2>Types.</h2>
                    <p>Стандарните неща, които очаквате от един типизиран език.</p>
                    <ul>
                        <li>Int</li>
                        <li>Integer</li>
                        <li>Bool</li>
                        <li>String</li>
                        <li>Double</li>
                        <li>etc.</li>
                    </ul>
                </section>

                <section>
                    <p>Нека имаме функцията <string>first</string>, която връща първи елемент на списък.</p>
                    <pre><code class="haskell">
-- d.hs
first [] = error "Empty list"
first (x:xs) = x

-- first [1,2,3] -> 1
-- first ["asd", "wtf"] -> "asd"
-- first [True, False] -> True
                    </code></pre>
                    <p>Според вас, каква е сигнатурата на <em>first</em>?</p>
                </section>

                <section>
                    <h2>Polymorphic functions</h2>
                    <pre><code class="haskell">
-- d.hs
first :: [a] -> a
first [] = error "Empty list"
first (x:xs) = x
</code></pre>
                <p><strong>a</strong> може да е всякакъв тип.</p>
                </section>

                <section>
                    <h2>Typeclasses.</h2>
                    <p>Малко по-дълбоко.</p>
                    <pre><code class="haskell">
-- e.hs
inList needle [] = False
inList needle (x:xs)
   | needle == x = True
   | otherwise = inList needle xs
</code></pre>

<pre class="fragment"><code class="haskell">
*Main> :t inList
inList :: Eq a => a -> [a] -> Bool
</code></pre>
                </section>

                <section>
                    <h2>Typeclasses ~~ Interfaces</h2>
                    <ul>
                        <li>Типовете сами казват към кои типови класовe приднадлежат.</li>
                        <li>Това ги задължава да имплементират определени функции.</li>
                    </ul>
                </section>
                <section>
                    <p>Така изглежда Eq в Haskell</p>
                    <pre><code class="haskell">
class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
    x == y = not (x /= y)
    x /= y = not (x == y)
                    </code></pre>

                    <div class="fragment">
                    <p>Дефинираме си нов тип.</p>
                    <pre><code class="haskell">
data TrafficLight = Red | Yellow | Green
                    </code></pre>
                    </div>

                    <div class="fragment">
                    <p>Добавяме TrafficLight към Eq</p>
                    <pre><code class="haskell">
instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
                    </code></pre>
                    </div>
                </section>

                <section>
                    <h2>Referential Transperency</h2>
                    <p>Една функция, извикана два пъти с еднакви аргументи, трябва да даде един и същи резултат.</p>
                    <pre><code class="python">
# Python
from random import randint
randint(1, 10) # 5
randint(1, 10) # 6
</code></pre>
                </section>

                <section>
                    <h2>Как правим <strong>random</strong> в Haskell?</h2>
                    <h2>Как правим <strong>IO</strong> в Haskell?</h2>
                    <h2>Как пазим <strong>състояние</strong> в Haskell?</h2>
                </section>

                <section>
                    <h2>return 4;</h2>
                    <pre><code class="haskell">
-- f.hs
import System.Random

randomRange a b = getStdRandom (randomR (a,b))
</code></pre>

<pre><code class="haskell">
randomR :: (RandomGen g, Random a) => (a, a) -> g -> (a, g)
</code></pre>
                <p>Счупихме Haskell ;(</p>
                </section>

                <section>
                    <h2>Сигнатурата на randomRange?</h2>
                    <p class="fragment">randomRange :: Random a => a -> a -> IO a</p>
                </section>

                <section>
                    <img src="images/8jO2b44.png">
                </section>

                <section>
                    <img src="images/io-monad.jpg">
                </section>

                <section>
                    <h2>IO a</h2>
                    <img src="images/luggage.png">
                </section>

                <section>
                    <h2>Не може да направим следното нещо:</h2>
                    <h3>f :: IO String -> String</h3>
                </section>

                <section>
                    <h2>Pure vs. Impure functions</h2>
                    <img src="images/yinyang.gif">
                </section>

                <section>
                    <h2>IO е като зомби зараза.</h2>
                    <p>Каквото се докосне до IO, става IO</p>
                    <img src="images/Zombie.png">
                </section>

                <section>
                    <h2>Hello World!</h2>
                    <pre><code class="haskell">
-- g.hs
main :: IO ()
main = putStrLn "Hello World!"
</code></pre>
                </section>

                <section>
                    <h2>Read & Print</h2>
                    <pre><code>
-- h.hs
main :: IO ()
main = getLine >>= putStrLn
</code></pre>
                <p>=<<, >>=, <-, ->, <*>, <$>, asd, wtf, etc.</p>
                </section>

                <section>
                    <h2>Do Syntax</h2>
                    <pre><code>
-- i.hs
import System.Random

randomRange :: Random a => a -> a -> IO a
randomRange a b = getStdRandom (randomR (a,b))

main :: IO ()
main = do
    name <- getLine
    putStrLn $ "Hello, " ++ name
    randomNumber <- randomRange 1 10 :: (IO Int)
    let squareRandom = randomNumber * randomNumber
    putStrLn $ "Your lucky number is : " ++ (show randomNumber)
    putStrLn $ "And the square is : " ++ (show squareRandom)
</code></pre>
                </section>

                <section>
                    <h2>Do you even math?</h2>
                </section>

                <section>
                    <h2>Книжка за четене*</h2>
                    <img src="images/learn.jpg">
                    <p>* не се подвеждайте от цветното.</p>
                </section>

                <section>
                    <h2>И все пак да се представя.</h2>
                    <h3>@Rado_g</h3>
                    <h3>GitHub.com/RadoRado</h3>
                    <h3>http://hackbulgaria.com</h3>
                    <h3>http://hackfmi.com</h3>
                </section>

                <section>
                    <img src="images/end.jpg">
                </section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>

		<script>

			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
                slideNumber : true,

				theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
				transition: "concave", // default/cube/page/concave/zoom/linear/fade/none

				// Parallax scrolling
				// parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
				// parallaxBackgroundSize: '2100px 900px',

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
					{ src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
				]
			});

		</script>

	</body>
</html>
